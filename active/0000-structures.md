- Start Date: 2015-02-07
- RFC PR:
- ember-cli Issue:

# Summary

Create the concept of Structures in ember-cli as an abstraction to represent an asset organization structure with matching resolver lookup pattern(s).

# Motivation

### Fixing usePodsByDefault
This would provide a clean way to define a `structure` option for the Generate and Destroy commands in ember-cli. We will be able to create aliases for the two structures `-basic` and `-pod` which will set the `--structure` option to the selected value. This will provide a better way to handle the `usePodsByDefault` (soon to be `usePods`) config flag. We're currently using it to determine when to invert the value of the `--pod` flag, which was originally a quick hack to provide a way to always generate pods without needing the flag. Instead, it could be intelligently used to override the default structure value when generating a blueprint.

### Two party system?
Currently we only support two structures in ember-cli, 'basic' and 'pod', and both have support built into the resolver. For blueprints that support both structure types, we've currently worked around it in a way that doesn't provide room for easy expansion (the blueprint currently depends on a `pod` Boolean set on its model). Much of the pod logic is not as loosely coupled as I'd like.

If we were ever needing of a new organizational structure, it would be difficult to add support for it while providing backward compatibility with previously supported structures. This would allow support to continue as needed, or even through an addon*.

### Escape Hatch

I'd like to make Structures the way we define the file organization schemes we use, as well as how the resolver is extended in ember-cli. This will give us an escape hatch come time we need to add or change schemes with little to no refactoring necessary.

# Detailed design
### Overview
Structures would be a sibling to Blueprints, and be depended upon by Blueprints for blueprint generation and destruction. The token names for creating the filepath would be generated from a set of rules defined in the structure to provide the segments that makeup the filepath. The structures for use in a project would be generated by the Project model.

It would be possible (but probably not desirable), to allow a structure in a project level `structures` folder to let custom structures be picked up (like we do for blueprints).

### Requirements
Ember-cli would contain it's own built-in structures, `basic` and `pod`. Each structure should include the following:


* Token logic
  * Provide token names/values used for fileMapTokens
* isSupported method
  * Runs a series of checks to see if a passed in blueprint can support the structure
* Resolver lookup pattern/rules
  * (if any, the basic structure wouldn't need any)


### Rough Concept
Structures would be contained in a folder on the root of the ember-cli project, much like the blueprints folder. Structures should be node modules, named by their structure name, and only contain an object to be used in the creation of a new Structure instance:
```js
// ./structures/pod.js
module.exports = {
  // test to determine if this blueprint can support this structure
  isSupported: function(blueprint) {
    var files = blueprint.files();
    return files.join().match(/__path__/);
  },
  tokens: {
    // values used in creating tokens
    name: function(options) {
      return options.blueprintName;
    },
    path: function(options) {
      return path.join(options.podPath, options.dasherizedModuleName);
    },
    test: function(options) {
      return options.blueprintName;
    }
  },
  resolver: {
    // rules for resolving go here, still need to figure out how this would look.
  }
};

```
Project would get a couple convenience methods for looking up and adding structures.

```js
Project.prototype.lookupStructures = function() {
  // pseudo lookup code to get folder contents and return as an array
  var structures = glob.sync(path.join(this.root,'structures','*'));

  return structures;
}

Project.prototype.buildStructure = function(path) {
  var structureOptions = require(path);
  var Constructor = Structure.extend(structureOptions);
  return new Constructor;
}

Project.prototype.structures = function(options){
  if (this._structures) { return this._structures; }
  // lookup structures in project
  this._structures = this.lookupStructures()
    .map(this.buildStructure).bind(this);

  return this._structures;
}
```
Blueprint changes would require a way to get the available structures to determine the current structure. From there the currentStructure is used to extract the values for fileMapTokens.

```js
Blueprint.prototype.getStructure = function(options) {
  var availableStructures = this.project.structures();
  // if the structure passed in options isn't supported fall back to default
  if (availableStructures[options.structure].isSupported(this)) {
    return availableStructures[options.structure];
  }
  return availableStructures['basic'];
}

Blueprint.prototype._fileMapTokens = function(options) {
  var currentStructure = this.getStructure(options);
  var standardTokens = {
    __name__: function(options) {
      return currentStructure.getToken('name',options);
    },
    __path__: function(options) {
      return currentStructure.getToken('path',options);
    },
    __test__: function(options) {
      return currentStructure.getToken('test',options);
    }
  };

  var customTokens = this.fileMapTokens(options) || options.fileMapTokens || {};
  return merge(standardTokens, customTokens);
};

```

The resolver would require some modification to allow the ability to pickup new rules through ember-cli, and I haven't completely investigated that part yet.

```js
// broccoli/ember-app.js

// something to insert the resolver rules into the app resolver goes here...

```


### Steps to implement
After the Structure class has been completed, the first step of this would probably be to extract pod lookup patterns from the resolver into a structure and implement them in ember-cli


# Drawbacks

It may be a overly-complicated solution for a problem that we don't have many use cases for yet.

# Alternatives

This could be built into blueprints directly as an object without the need for a stand alone class.

# Unresolved questions

How can we allow the resolver to be augmented with additional lookup patterns?
